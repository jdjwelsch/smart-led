'use strict';

/**
 * radial-color-picker/color-wheel v2.2.0
 *
 * https://github.com/radial-color-picker/color-wheel
 *
 * Copyright (c) 2018-present, Rosen Kanev
 * Released under the MIT License.
 */
/**
 * Modified version of Lea Verou's
 * {@link https://github.com/leaverou/conic-gradient conic-gradient}.
 *
 * @example
 * paintColorWheelToCanvas(document.querySelector('#canvas'), 250);
 *
 * @param   {HTMLCanvasElement} canvas Canvas to paint the color wheel
 * @param   {Number}            size   Color wheel radius in pixels
 * @returns {HTMLCanvasElement} canvas The passed canvas for easier chaining
 */
function paintColorWheelToCanvas(canvas, size) {
  var half = size / 2;
  var radius = Math.sqrt(2) * half;
  var deg = Math.PI / 180;
  var pi2 = Math.PI * 2;
  canvas.width = canvas.height = size;
  var ctx = canvas.getContext('2d'); // .02: To prevent empty blank line and corresponding moire
  // only non-alpha colors are cared now

  var thetaOffset = 0.5 * deg + 0.02; // Transform coordinate system so that angles start from the top left, like in CSS

  ctx.translate(half, half);
  ctx.rotate(-Math.PI / 2);
  ctx.translate(-half, -half);

  for (var i = 0; i < 360; i += 0.5) {
    ctx.fillStyle = "hsl(" + i + ", 100%, 50%)";
    ctx.beginPath();
    ctx.moveTo(half, half);
    var beginArg = i * deg;
    var endArg = Math.min(pi2, beginArg + thetaOffset);
    ctx.arc(half, half, radius, beginArg, endArg);
    ctx.closePath();
    ctx.fill();
  }

  return canvas;
}

/**
 * radial-color-picker/rotator v2.1.0
 *
 * https://github.com/radial-color-picker/rotator
 *
 * Copyright (c) 2018-present, Rosen Kanev
 * Released under the MIT License.
 */
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var TO_DEGREES = 180 / Math.PI;
var normalizeAngle = function normalizeAngle(angle) {
  var mod = angle % 360;
  return mod < 0 ? 360 + mod : mod;
};
var getRotationFromCoords = function getRotationFromCoords(_ref, rect) {
  var x = _ref.x,
      y = _ref.y;
  var cx = rect.left + rect.width / 2;
  var cy = rect.top + rect.height / 2;
  return Math.atan2(y - cy, x - cx) * TO_DEGREES;
};
var noop = function noop() {};

/**
 * Modified version of Denis Radin's
 * {@link https://github.com/PixelsCommander/Propeller Propeller}.
 */

var Rotator =
/*#__PURE__*/
function () {
  function Rotator(element, options) {
    this.active = false;
    this._angle = 0;
    this.element = element;
    this.element.style.willChange = 'transform';
    this.initOptions(options);
    this.updateCSS();
    this.bindHandlers();
    this.addListeners();
  }

  var _proto = Rotator.prototype;

  _proto.initOptions = function initOptions(options) {
    options = options || {};
    this.onRotate = options.onRotate || noop;
    this.onDragStart = options.onDragStart || noop;
    this.onDragStop = options.onDragStop || noop;
    this._angle = options.angle || 0;
  };

  _proto.bindHandlers = function bindHandlers() {
    this.onRotationStart = this.onRotationStart.bind(this);
    this.onRotated = this.onRotated.bind(this);
    this.onRotationStop = this.onRotationStop.bind(this);
  };

  _proto.addListeners = function addListeners() {
    this.element.addEventListener('touchstart', this.onRotationStart, {
      passive: true
    });
    document.addEventListener('touchmove', this.onRotated, {
      passive: false
    });
    document.addEventListener('touchend', this.onRotationStop, {
      passive: true
    });
    document.addEventListener('touchcancel', this.onRotationStop, {
      passive: true
    });
    this.element.addEventListener('mousedown', this.onRotationStart, {
      passive: true
    });
    document.addEventListener('mousemove', this.onRotated, {
      passive: false
    });
    document.addEventListener('mouseup', this.onRotationStop, {
      passive: true
    });
    document.addEventListener('mouseleave', this.onRotationStop, {
      passive: false
    });
  };

  _proto.removeListeners = function removeListeners() {
    this.element.removeEventListener('touchstart', this.onRotationStart);
    document.removeEventListener('touchmove', this.onRotated);
    document.removeEventListener('touchend', this.onRotationStop);
    document.removeEventListener('touchcancel', this.onRotationStop);
    this.element.removeEventListener('mousedown', this.onRotationStart);
    document.removeEventListener('mousemove', this.onRotated);
    document.removeEventListener('mouseup', this.onRotationStop);
    document.removeEventListener('mouseleave', this.onRotationStop);
  };

  _proto.destroy = function destroy() {
    this.onRotationStop();
    this.removeListeners();
  };

  _proto.onRotationStart = function onRotationStart(event) {
    if (event.type === 'touchstart' || event.button === 0) {
      this.initDrag();
      this.onDragStart(event);
    }
  };

  _proto.onRotationStop = function onRotationStop() {
    if (this.active) {
      this.active = false;
      this.onDragStop();
    }

    this.active = false;
  };

  _proto.onRotated = function onRotated(event) {
    if (this.active) {
      event.preventDefault();
      var point = event.targetTouches ? event.targetTouches[0] : event;
      this.updateAngleToMouse({
        x: point.clientX,
        y: point.clientY
      });
      this.updateCSS();
      this.onRotate(this._angle);
    }
  };

  _proto.setAngleFromEvent = function setAngleFromEvent(ev) {
    var newAngle = getRotationFromCoords({
      x: ev.clientX,
      y: ev.clientY
    }, this.element.getBoundingClientRect()); // atan2 gives values between -180 to 180 deg
    // add 90 degrees offset so that it starts from 0 deg (or red)
    // and then normalize negative values

    this._angle = normalizeAngle(newAngle + 90);
    this.updateCSS();
    this.onRotate(this._angle);
  };

  _proto.updateAngleToMouse = function updateAngleToMouse(newPoint) {
    var newMouseAngle = getRotationFromCoords(newPoint, this.element.getBoundingClientRect());

    if (!this.lastMouseAngle) {
      this.lastElementAngle = this._angle;
      this.lastMouseAngle = newMouseAngle;
    }

    this._angle = normalizeAngle(this.lastElementAngle + newMouseAngle - this.lastMouseAngle);
  };

  _proto.initDrag = function initDrag() {
    this.active = true;
    this.lastMouseAngle = undefined;
    this.lastElementAngle = undefined;
  };

  _proto.updateCSS = function updateCSS() {
    this.element.style.transform = "rotate(" + this._angle + "deg)";
  };

  _createClass(Rotator, [{
    key: "angle",
    get: function get() {
      return this._angle;
    },
    set: function set(value) {
      if (this._angle !== value) {
        this._angle = normalizeAngle(value);
        this.updateCSS();
      }
    }
  }]);

  return Rotator;
}();

//
var script = {
  rcp: null,
  name: 'ColorPicker',
  props: {
    hue: {
      default: 0
    },
    saturation: {
      default: 100
    },
    luminosity: {
      default: 50
    },
    alpha: {
      default: 1
    },
    step: {
      default: 2
    },
    mouseScroll: {
      default: false
    },
    variant: {
      default: 'collapsible' // collapsible | persistent

    },
    disabled: {
      default: false
    },
    initiallyCollapsed: {
      default: false
    }
  },
  data: function data() {
    return {
      ssrHue: 0,
      isPaletteIn: !this.initiallyCollapsed,
      isKnobIn: !this.initiallyCollapsed,
      isPressed: false,
      isRippling: false,
      isDragging: false
    };
  },
  computed: {
    color: function color() {
      return "hsla(".concat(this.hue, ", ").concat(this.saturation, "%, ").concat(this.luminosity, "%, ").concat(this.alpha, ")");
    }
  },
  watch: {
    hue: function hue(angle) {
      this.rcp.angle = angle;
    }
  },
  created: function created() {
    // update the SSR value once when the component is created
    // prevents knob jumping when using Server Side Rendering
    // where the knob's position is updated only after the client-side code is executed (on mount)
    this.ssrHue = this.hue;
  },
  mounted: function mounted() {
    var _this = this;

    // ignore testing code that will be removed by dead code elimination for production

    /* istanbul ignore next */
    if (process.env.NODE_ENV === 'development' && this.initiallyCollapsed && this.variant === 'persistent') {
      console.warn("Incorrect config: using variant=\"persistent\" and :initiallyCollapsed=\"true\" at the same time is not supported.");
    }

    var isConicGradientSupported = getComputedStyle(this.$refs.palette).backgroundImage.includes('conic'); // ignore conic-gradient support & polyfill

    /* istanbul ignore else */

    if (!isConicGradientSupported) {
      paintColorWheelToCanvas(this.$refs.palette.firstElementChild, this.$el.offsetWidth || 280);
    }

    this.rcp = new Rotator(this.$refs.rotator, {
      angle: this.hue,
      onRotate: this.updateColor,
      onDragStart: function onDragStart() {
        _this.isDragging = true;
      },
      onDragStop: function onDragStop() {
        _this.isDragging = false;
      }
    });
  },
  methods: {
    onScroll: function onScroll(ev) {
      if (this.isPressed || !this.isKnobIn) return;
      ev.preventDefault();

      if (ev.deltaY > 0) {
        this.rcp.angle += this.step;
      } else {
        this.rcp.angle -= this.step;
      }

      this.updateColor(this.rcp.angle);
    },
    rotate: function rotate(ev, isIncrementing) {
      if (this.disabled || this.isPressed || !this.isKnobIn) return;
      var multiplier = isIncrementing ? 1 : -1;

      if (ev.ctrlKey) {
        multiplier *= 6;
      } else if (ev.shiftKey) {
        multiplier *= 3;
      }

      this.rcp.angle += this.step * multiplier;
      this.updateColor(this.rcp.angle);
    },
    updateColor: function updateColor(hue) {
      this.$emit('input', hue);
    },
    rotateToMouse: function rotateToMouse(ev) {
      if (this.isPressed || !this.isKnobIn) return;
      this.rcp.setAngleFromEvent(ev);
    },
    selectColor: function selectColor() {
      this.isPressed = true;

      if (this.isPaletteIn && this.isKnobIn) {
        this.$emit('change', this.hue);
        this.isRippling = true;
      } else {
        this.isPaletteIn = true;
      }
    },
    togglePicker: function togglePicker() {
      if (this.variant !== 'persistent') {
        if (this.isKnobIn) {
          this.isKnobIn = false;
        } else {
          this.isKnobIn = true;
          this.isPaletteIn = true;
        }
      }

      this.isRippling = false;
      this.isPressed = false;
    },
    hidePalette: function hidePalette() {
      if (!this.isKnobIn) {
        this.isPaletteIn = false;
      }
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.rcp.destroy();
    this.rcp = null;
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function () {
      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}

var normalizeComponent_1 = normalizeComponent;

/* script */
const __vue_script__ = script;
/* template */
var __vue_render__ = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    {
      staticClass: "rcp",
      class: { dragging: _vm.isDragging, disabled: _vm.disabled },
      attrs: { tabindex: _vm.disabled ? -1 : 0 },
      on: {
        keyup: function($event) {
          if (
            !("button" in $event) &&
            _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
          ) {
            return null
          }
          return _vm.selectColor($event)
        },
        keydown: [
          function($event) {
            if (
              !("button" in $event) &&
              _vm._k($event.keyCode, "up", 38, $event.key, ["Up", "ArrowUp"]) &&
              _vm._k($event.keyCode, "right", 39, $event.key, [
                "Right",
                "ArrowRight"
              ])
            ) {
              return null
            }
            if ("button" in $event && $event.button !== 2) {
              return null
            }
            $event.preventDefault();
            _vm.rotate($event, true);
          },
          function($event) {
            if (
              !("button" in $event) &&
              _vm._k($event.keyCode, "down", 40, $event.key, [
                "Down",
                "ArrowDown"
              ]) &&
              _vm._k($event.keyCode, "left", 37, $event.key, [
                "Left",
                "ArrowLeft"
              ])
            ) {
              return null
            }
            if ("button" in $event && $event.button !== 0) {
              return null
            }
            $event.preventDefault();
            _vm.rotate($event, false);
          }
        ]
      }
    },
    [
      _vm._ssrNode(
        "<div" +
          _vm._ssrClass("rcp__palette", _vm.isPaletteIn ? "in" : "out") +
          '><canvas></canvas></div> <div class="rcp__rotator"' +
          _vm._ssrStyle(
            null,
            {
              "pointer-events":
                _vm.disabled || _vm.isPressed || !_vm.isKnobIn ? "none" : null,
              transform: "rotate(" + _vm.ssrHue + "deg)"
            },
            null
          ) +
          "><div" +
          _vm._ssrClass("rcp__knob", _vm.isKnobIn ? "in" : "out") +
          "></div></div> <div" +
          _vm._ssrClass("rcp__ripple", { rippling: _vm.isRippling }) +
          _vm._ssrStyle(null, { borderColor: _vm.color }, null) +
          '></div> <button type="button"' +
          _vm._ssrClass("rcp__well", { pressed: _vm.isPressed }) +
          _vm._ssrStyle(null, { backgroundColor: _vm.color }, null) +
          "></button>"
      )
    ]
  )
};
var __vue_staticRenderFns__ = [];
__vue_render__._withStripped = true;

  /* style */
  const __vue_inject_styles__ = undefined;
  /* scoped */
  const __vue_scope_id__ = undefined;
  /* module identifier */
  const __vue_module_identifier__ = "data-v-473eb6ed";
  /* functional template */
  const __vue_is_functional_template__ = false;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ColorPicker = normalizeComponent_1(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    undefined,
    undefined
  );

ColorPicker.install = function (Vue) {
  Vue.component('ColorPicker', ColorPicker);
};

module.exports = ColorPicker;
