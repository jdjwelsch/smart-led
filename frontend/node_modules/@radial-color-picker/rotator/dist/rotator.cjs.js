/**
 * radial-color-picker/rotator v2.1.0
 *
 * https://github.com/radial-color-picker/rotator
 *
 * Copyright (c) 2018-present, Rosen Kanev
 * Released under the MIT License.
 */
'use strict';

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var TO_DEGREES = 180 / Math.PI;
var normalizeAngle = function normalizeAngle(angle) {
  var mod = angle % 360;
  return mod < 0 ? 360 + mod : mod;
};
var getRotationFromCoords = function getRotationFromCoords(_ref, rect) {
  var x = _ref.x,
      y = _ref.y;
  var cx = rect.left + rect.width / 2;
  var cy = rect.top + rect.height / 2;
  return Math.atan2(y - cy, x - cx) * TO_DEGREES;
};
var noop = function noop() {};

/**
 * Modified version of Denis Radin's
 * {@link https://github.com/PixelsCommander/Propeller Propeller}.
 */

var Rotator =
/*#__PURE__*/
function () {
  function Rotator(element, options) {
    this.active = false;
    this._angle = 0;
    this.element = element;
    this.element.style.willChange = 'transform';
    this.initOptions(options);
    this.updateCSS();
    this.bindHandlers();
    this.addListeners();
  }

  var _proto = Rotator.prototype;

  _proto.initOptions = function initOptions(options) {
    options = options || {};
    this.onRotate = options.onRotate || noop;
    this.onDragStart = options.onDragStart || noop;
    this.onDragStop = options.onDragStop || noop;
    this._angle = options.angle || 0;
  };

  _proto.bindHandlers = function bindHandlers() {
    this.onRotationStart = this.onRotationStart.bind(this);
    this.onRotated = this.onRotated.bind(this);
    this.onRotationStop = this.onRotationStop.bind(this);
  };

  _proto.addListeners = function addListeners() {
    this.element.addEventListener('touchstart', this.onRotationStart, {
      passive: true
    });
    document.addEventListener('touchmove', this.onRotated, {
      passive: false
    });
    document.addEventListener('touchend', this.onRotationStop, {
      passive: true
    });
    document.addEventListener('touchcancel', this.onRotationStop, {
      passive: true
    });
    this.element.addEventListener('mousedown', this.onRotationStart, {
      passive: true
    });
    document.addEventListener('mousemove', this.onRotated, {
      passive: false
    });
    document.addEventListener('mouseup', this.onRotationStop, {
      passive: true
    });
    document.addEventListener('mouseleave', this.onRotationStop, {
      passive: false
    });
  };

  _proto.removeListeners = function removeListeners() {
    this.element.removeEventListener('touchstart', this.onRotationStart);
    document.removeEventListener('touchmove', this.onRotated);
    document.removeEventListener('touchend', this.onRotationStop);
    document.removeEventListener('touchcancel', this.onRotationStop);
    this.element.removeEventListener('mousedown', this.onRotationStart);
    document.removeEventListener('mousemove', this.onRotated);
    document.removeEventListener('mouseup', this.onRotationStop);
    document.removeEventListener('mouseleave', this.onRotationStop);
  };

  _proto.destroy = function destroy() {
    this.onRotationStop();
    this.removeListeners();
  };

  _proto.onRotationStart = function onRotationStart(event) {
    if (event.type === 'touchstart' || event.button === 0) {
      this.initDrag();
      this.onDragStart(event);
    }
  };

  _proto.onRotationStop = function onRotationStop() {
    if (this.active) {
      this.active = false;
      this.onDragStop();
    }

    this.active = false;
  };

  _proto.onRotated = function onRotated(event) {
    if (this.active) {
      event.preventDefault();
      var point = event.targetTouches ? event.targetTouches[0] : event;
      this.updateAngleToMouse({
        x: point.clientX,
        y: point.clientY
      });
      this.updateCSS();
      this.onRotate(this._angle);
    }
  };

  _proto.setAngleFromEvent = function setAngleFromEvent(ev) {
    var newAngle = getRotationFromCoords({
      x: ev.clientX,
      y: ev.clientY
    }, this.element.getBoundingClientRect()); // atan2 gives values between -180 to 180 deg
    // add 90 degrees offset so that it starts from 0 deg (or red)
    // and then normalize negative values

    this._angle = normalizeAngle(newAngle + 90);
    this.updateCSS();
    this.onRotate(this._angle);
  };

  _proto.updateAngleToMouse = function updateAngleToMouse(newPoint) {
    var newMouseAngle = getRotationFromCoords(newPoint, this.element.getBoundingClientRect());

    if (!this.lastMouseAngle) {
      this.lastElementAngle = this._angle;
      this.lastMouseAngle = newMouseAngle;
    }

    this._angle = normalizeAngle(this.lastElementAngle + newMouseAngle - this.lastMouseAngle);
  };

  _proto.initDrag = function initDrag() {
    this.active = true;
    this.lastMouseAngle = undefined;
    this.lastElementAngle = undefined;
  };

  _proto.updateCSS = function updateCSS() {
    this.element.style.transform = "rotate(" + this._angle + "deg)";
  };

  _createClass(Rotator, [{
    key: "angle",
    get: function get() {
      return this._angle;
    },
    set: function set(value) {
      if (this._angle !== value) {
        this._angle = normalizeAngle(value);
        this.updateCSS();
      }
    }
  }]);

  return Rotator;
}();

module.exports = Rotator;
